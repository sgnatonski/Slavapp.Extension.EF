# Slavapp.Extension.EF

A set of extension methods for EntityFramework and IQueryable interface for quick sorting and filtering development

## Description

Project originated as a set of methods for quick query string translations into expression trees valid enough to be used as *where* and *order by* clauses, generated by EntityFramework.
Main purpose of it is to speed up development process by designing a simple and fast way to transform a HTTP query string (or any other string-based set of parameters) into corresponding expression trees, and in the end, into required SQL queries with very limited effort and code produced.

## Getting Started

### Dependencies

No dependencies

### Installing
```
Install-Package Slavapp.Extensions.EF
```
### Usage

To create a new map of sort expressions for a EF model simply define new class:
```
public class RegistrationSorting : BaseSorting<Registration>
{
    public RegistrationSorting()
    {
        SetSorting("RegistrationNumber", x => x.RegistrationNumber);
        SetSorting("FullName", x => x.LastName + " " + x.FirstName);
        SetSorting("PaymentBalance", x => x.PaymentBalance);
        SetSorting("Modified", x => x.Modified);
        SetSorting("Created", x => x.Created);
        SetSorting("AssignedTo", x => x.AssignedTo);
        SetSorting("JobCity", x => x.Addresses.OfType<JobAddress>().FirstOrDefault().City);
    }
}
```

SetSorting method accepts 2 arguments: a name and an expression. Name is a parameter which can be arbitrary string, not really connected to EF model, its something that client is responsible to know. When defining a sort option we need to specify how this name maps to EF model properties.
f. ex.
```
SetSorting("RegistrationNumber", x => x.RegistrationNumber); 
```
  will bind RegistrationNumber name to RegistrationNumber property, which means that we can sort by RegistrationNumber property using RegistrationNumber name.
```
SetSorting("FullName", x => x.LastName + " " + x.FirstName); 
```
  on the other hand will bind FullName name to a result of LastName and FirstName concatenation, which means that if we specify FullName parameter to sort on it will be translated to LastName + " " + FirstName expression.
There are many other, more complex ways to define how to sort given models, for instance by using child objects:
```
SetSorting("JobCity", x => x.Addresses.OfType<JobAddress>().FirstOrDefault().City);
```
  will use Addresses child collection to sort on Address.City property by simple usage of JobCity parameter
  
Filters can be defined as follows:

```
public class RegistrationFilter : BaseFilter<Registration>
{
    public RegistrationFilter()
    {
        SetFilter("RegistrationNumber", x => x.RegistrationNumber);
        SetFilter("FullName", x => x.LastName + " " + x.FirstName);
        SetFilter("PaymentBalance", x => x.PaymentBalance);
        SetFilter("Modified", x => x.Modified);
        SetFilter("Created", x => x.Created);
        SetFilter("AssignedTo", x => x.AssignedTo);
        SetFilter("JobCity", x => x.Addresses.OfType<JobAddress>().FirstOrDefault().City);
    }
}
```

Once defined, filters and sortings can be used as IQueryable extensions:

```
...
using Slavapp.Extensions.EF;

public IHttpActionResult GetRegistrations(string sortCols = null, string filter = null)
{
    var regs = this.dbContext.RegistrationSet
                .WithSort(sortCols)
                .WithFilter(filter)
                .ToList();
    return regs;
}
```
  
## Authors

Slawomir Gnatonski
